<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Chess</title>
	<style>
		body{margin:0;padding:0;background:#000}
		table{margin: auto;margin-top: 50vh;transform: translateY(-50%)}
		td{width:65px;height:65px;border:2px solid}
		.black{background:#433}
		.white{background:#FB1}
		.select{border-color:red}
		#pawn[data-player='2']{background-image: url('img/pawnB.png'); background-size: 100% 100%}
		#pawn[data-player='1']{background-image: url('img/pawnW.png'); background-size: 100% 100%}
		#rook[data-player='2']{background-image: url('img/rookB.png'); background-size: 100% 100%}
		#rook[data-player='1']{background-image: url('img/rookW.png'); background-size: 100% 100%}
		#bishop[data-player='2']{background-image: url('img/bishopB.png'); background-size: 100% 100%}
		#bishop[data-player='1']{background-image: url('img/bishopW.png'); background-size: 100% 100%}
		#knight[data-player='2']{background-image: url('img/knightB.png'); background-size: 100% 100%}
		#knight[data-player='1']{background-image: url('img/knightW.png'); background-size: 100% 100%}
		#queen[data-player='2']{background-image: url('img/queenB.png'); background-size: 100% 100%}
		#queen[data-player='1']{background-image: url('img/queenW.png'); background-size: 100% 100%}
		#king[data-player='2']{background-image: url('img/kingB.png'); background-size: 100% 100%}
		#king[data-player='1']{background-image: url('img/kingW.png'); background-size: 100% 100%}
	</style>
</head>
<body>
	<script>
		const chess = 
		{ 
			init : function(row, col)
			{	
				this.row = row
				this.col = col
				this.body = document.body
				this.tabHTML = document.createElement('table')
				this.tabJS = []
				this.tmp
				this.turn = 1
				this.pieces = ['pawn','rook','knight','bishop','queen','king','bishop','knight','rook']
				
				for(let i = this.row-1; i >= 0; i--)
				{
					const tr = document.createElement('tr')
					this.tabJS[i] = []
					for(let j = 0; j < this.col; j++)
					{
						const td = document.createElement('td')
						td.dataset.row = i
						td.dataset.column = j
						if((i+1) % 2 == 0)
						{
							if((j+1) % 2 == 0)
								td.classList.add('white')
							else
								td.classList.add('black')
						}
						else
						{
							if((j+1) % 2 != 0)
								td.classList.add('white')
							else
								td.classList.add('black')		
						}
						
						if(i == 1)
						{
							td.id = this.pieces[0]
							td.dataset.player = 1
						}
						
						if(i == this.row - 2)
						{
							td.id = this.pieces[0]
							td.dataset.player = 2
						}
						
						if(i == 0)
						{
							td.id = this.pieces[j+1]
							td.dataset.player = 1
						}
						
						if(i == this.row - 1)
						{
							td.id = this.pieces[j+1]
							td.dataset.player = 2
						}
						
						td.addEventListener('click', function()
						{
							if(chess.tmp != undefined)
							{
								chess.tmp.classList.remove('select')
								if(chess.tmp.id)
								{
									if(chess.tmp.getAttribute('data-player') == chess.turn)
										if(chess.pieces.includes(chess.tmp.id))
											if(chess.isAllowedMove(chess.tmp, this))
												chess.deplace(chess.tmp, this)
									chess.tmp = undefined
									return
								}
							}
							this.classList.add('select')
							chess.tmp = this
						})
						this.tabJS[i][j] = td
						tr.appendChild(td)
					}
					this.tabHTML.appendChild(tr)
				}
				this.body.appendChild(this.tabHTML)
			},
			
			isAllowedMove : function(oldPos, newPos)
			{
				const newPosRow = Number(newPos.getAttribute('data-row'))
				const newPosCol = Number(newPos.getAttribute('data-column'))
				const oldPosRow = Number(oldPos.getAttribute('data-row'))
				const oldPosCol = Number(oldPos.getAttribute('data-column'))
				const newPosPlayer = newPos.getAttribute('data-player')
				const player = this.turn
				let isAllowedMove = false
				switch(oldPos.id)
				{
					case 'pawn' : 
					{
						const sign = this.turn == 1 ? -1 : 1
						const side = this.turn == 1 ? 1 : (this.row - 2)
						//SI LA NOUVELLE CASE EST A UNE LIGNE DEVANT LA SELECTION ET ( (DANS LA MEME COLONNE ET VIDE) OU (DANS UNE COLONNE AVOISINANTE ET D'UNE PIECE ADVERSE) ).
						if((newPosRow + (1 * sign) == oldPosRow && ((newPosCol == oldPosCol && newPos.id == '') || (newPos.id != '' && (newPosCol + 1 == oldPosCol || newPosCol - 1 == oldPosCol) && newPosPlayer != player)))
						//OU SI LA NOUVELLE CASE EST A 2 LIGNE DEVANT LA SELECTION ET QUE LA SELECTION EST A LA POSITION INITIAL ET QUE LA NOUVELLE CASE EST VIDE ET QUE LA CASE ENTRE EST VIDE ET QUE ELLE EST DANS LA MEME COLONNE.
							|| newPosRow + (2 * sign) == oldPosRow && (oldPosRow == side) && this.tabJS[newPosRow + (1*sign)][newPosCol].id == '' && newPos.id == '' && (newPosCol == oldPosCol))
						{
							isAllowedMove = true
						}
						break;
					}
					case 'knight' :
					{
						const posRowColDif = [1, -1, 3, -3]
						//SI LA DIFFERENCE ENTRE LA SOMME DU X ET DU Y DE LA SELECTION ET DU X ET DU Y DE LA NOUVELLE CASE EST UN DES NOMBRES DU TABLEAU
						if(posRowColDif.includes((oldPosCol + oldPosRow) - (newPosCol + newPosRow)) 
						//ET QUE (LA COLONNE DE LA SELECTION EST DIFFERENTE DE CELLE DE LA NOUVELLE CASE ET LA LIGNE DE LA SELECTION EST DIFFERENTE DE CELLE DE LA NOUVELLE CASE) 
							&& (oldPosCol !== newPosCol & oldPosRow !== newPosRow)
						//ET QUE LA COLONNE DE LA SELECTION SOIT A PAS PLUS DE 2 DE DIFFERENCE AVEC LA COLONNE DE LA NOUVELLE CASE ET QUE LA LIGNE DE LA SELECTION SOIT A PAS PLUS DE 2 DE DIFFERENCE AVEC LA LIGNE DE LA NOUVELLE CASE
							&& (oldPosCol - newPosCol <= 2 && oldPosCol - newPosCol >= -2) && (oldPosRow - newPosRow <= 2 && oldPosRow - newPosRow >= -2)
						//ET QUE LA NOUVELLE CASE NE CONTIENNE PAS UNE PIECE ALLIE
							&& newPosPlayer != player)
						{
							isAllowedMove = true
						}
						break;
					}
					case 'king' :
					{
						//SI LA NOUVELLE CASE EST A 1 CASE D'ECART MAX DE LA SELECTION ET QU'ELLE N'EST PAS ALLIE
						if((oldPosRow - newPosRow <= 1 && oldPosRow - newPosRow >= -1) && (oldPosCol - newPosCol <= 1 && oldPosCol - newPosCol >= -1) && newPosPlayer != player)
						{
							isAllowedMove = true
						}
						break;
					}
					case 'rook':
					case 'queen':
					{ //SI LA NOUVELLE CASE A LA MEME COLONNE QUE LA SELECTION OU BIEN LA MEME LIGNE ET QUE LA NOUVELLE CASE N'EST PAS ALLIE
						if((oldPosRow == newPosRow || oldPosCol == newPosCol) && newPosPlayer != player)
						{//SI LA NOUVELLE CASE N'EST PAS SUR LA MEME LIGNE
							if(oldPosRow != newPosRow)
							{
								let checkPosRow = oldPosRow
								const sign = oldPosRow > newPosRow ? -1 : 1
								//CHECK DE CHACUNE DES CASES ENTRE LA SELECTION ET LA NOUVELLE. RETURN FALSE SI UNE D'ENTRE ELLE POSSEDE UN ID
								while(checkPosRow != newPosRow)
								{
									checkPosRow += sign
									if(this.tabJS[checkPosRow][oldPosCol].id && checkPosRow != newPosRow)
										return false
								}
							}//SINON LA NOUVELLE CASE N'EST PAS SUR LA MEME COLONNE
							else
							{
								let checkPosCol = oldPosCol
								const sign = oldPosCol > newPosCol ? -1 : 1
								//CHECK DE CHACUNE DES CASES ENTRE LA SELECTION ET LA NOUVELLE. RETURN FALSE SI UNE D'ENTRE ELLE POSSEDE UN ID
								while(checkPosCol != newPosCol)
								{
									checkPosCol += sign
									if(this.tabJS[oldPosRow][checkPosCol].id && checkPosCol != newPosCol)
										return false
								}
							}
								isAllowedMove = true
						}
						if(oldPos.id != 'queen')
							break;
					}
					case 'bishop':
					case 'queen':
					{//SI LA NOUVELLE CASE EST EN DIAGONAL OU ANTIDIAGONAL DE LA SELECTION ET QU'ELLE N'EST PAS ALLIE
						if((newPosRow + newPosCol == oldPosRow + oldPosCol || newPosRow - newPosCol == oldPosRow - oldPosCol) && newPosPlayer != player)
						{
							let checkPosRow = oldPosRow
							let checkPosCol = oldPosCol
							let signRow
							let signCol							//SI LA LIGNE DE LA SELECTION EST PLUS GRANDE QUE CELLE DE LA NOUVELLE CASE ON DECREMENTE SINON ON INCREMENTE
							if(oldPosRow > newPosRow)
								signRow = -1
							else
								signRow = 1
							//SI LA COLONNE DE LA SELECTION EST PLUS GRANDE QUE CELLE DE LA NOUVELLE CASE ON DECREMENTE SINON ON INCREMENTE
							if(oldPosCol > newPosCol)
								signCol = -1
							else
								signCol = 1
								//CHECK DE CHACUNE DES CASES ENTRE LA SELECTION ET LA NOUVELLE. RETURN FALSE SI UNE D'ENTRE ELLE POSSEDE UN ID
								//TESTER JUSTE LA LIGNE EST SUFFISANT CAR LA COLONNE EST INCREMENTE EN MEME TEMPS
								while(checkPosRow != newPosRow)
								{
									checkPosRow += signRow
									checkPosCol += signCol
									if(this.tabJS[checkPosRow][checkPosCol].id && checkPosRow != newPosRow)
										return false
								}
								isAllowedMove = true
						}
						break;
					}
				}
				
				return isAllowedMove
			},
			
			deplace : function(oldPos, newPos)
			{
				this.turn = (this.turn == 1) ? 2 : 1
				newPos.setAttribute('data-player', oldPos.getAttribute('data-player'))
				oldPos.removeAttribute('data-player')
				newPos.id = oldPos.id
				oldPos.removeAttribute('id')
			}
		}
		
		chess.init(8,8)
	</script>
</body>
</html>