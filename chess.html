<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Chess</title>
	<style>
		body{margin:0;padding:0;background:#000}
		table{margin: auto;margin-top: 50vh;transform: translateY(-50%)}
		td{width:66px;height:66px;border:2px solid;border-radius:6px}
		div{border:3px solid #BADA55;position: absolute;background:#fff173;height:42px;width:110px;border-radius:6px; left:50%; top:50%;transform: translateX(-50%); margin-top: -33px; text-align: center}
		button{background: #BADA55;border-radius:6px;display:block; margin: auto}
		.black{background:#433}
		.white{background:#FB1}
		.select{background:#23D}
		.highlight{background:#1CE}
		.check{background:#BA2B1E}
		#pawn[data-player='-1']{background-image: url('img/pawnB.png'); background-size: 100% 100%}
		#pawn[data-player='1']{background-image: url('img/pawnW.png'); background-size: 100% 100%}
		#rook[data-player='-1']{background-image: url('img/rookB.png'); background-size: 100% 100%}
		#rook[data-player='1']{background-image: url('img/rookW.png'); background-size: 100% 100%}
		#bishop[data-player='-1']{background-image: url('img/bishopB.png'); background-size: 100% 100%}
		#bishop[data-player='1']{background-image: url('img/bishopW.png'); background-size: 100% 100%}
		#knight[data-player='-1']{background-image: url('img/knightB.png'); background-size: 100% 100%}
		#knight[data-player='1']{background-image: url('img/knightW.png'); background-size: 100% 100%}
		#queen[data-player='-1']{background-image: url('img/queenB.png'); background-size: 100% 100%}
		#queen[data-player='1']{background-image: url('img/queenW.png'); background-size: 100% 100%}
		#king[data-player='-1']{background-image: url('img/kingB.png'); background-size: 100% 100%}
		#king[data-player='1']{background-image: url('img/kingW.png'); background-size: 100% 100%}
	</style>
</head>
<body>
	<audio src='http://s1download-universal-soundbank.com/wav/9085.wav'></audio>
	<script>
		function clickOnBtn()
		{
			chess.body.removeChild(document.querySelector('table'))
			chess.selection = undefined
			chess.init(row, col, bot)
		}
		
		function clickOnTd()
		{
			chess.play(this)
		}
		
		const chess = 
		{ 
			init : function(row, col, bot)
			{	
				this.row = row
				this.col = col
				this.body = document.body
				this.tabHTML = document.createElement('table')
				this.tabJS = []
				this.selection
				this.turn = 1
				this.pieces = ['pawn','rook','knight','bishop','king','queen','bishop','knight','rook']
				this.rowColInCheck = null
				this.threatToKing = null
				this.threatToKingCommon = null
				this.limitedPiece = null
				this.botBool = bot
				
				for(let i = this.row-1; i >= 0; i--)
				{
					const tr = document.createElement('tr')
					this.tabJS[i] = []
					for(let j = 0; j < this.col; j++)
					{
						const td = document.createElement('td')
						td.dataset.row = i
						td.dataset.column = j
						
						this.paving(td, i, j)
						this.initialPos(td, i, j)
						td.addEventListener('click', clickOnTd)
						
						this.tabJS[i][j] = td
						tr.appendChild(td)
					}
					this.tabHTML.appendChild(tr)
				}
				this.body.appendChild(this.tabHTML)
			},
			
			play : function(selection)
			{
				//SELECTION D'UNE CASE AU PREMIER TOUR SEULEMENT
				if(this.selection == undefined)
					this.selection = selection
				//SELECTION D'UNE CASE SEULEMENT SI ELLE EST OCCUPEE PAR UN ALLIE
				if(selection.id && selection.dataset.player == this.turn)
				{
					this.clean()
					this.selection = selection
					selection.classList.add('select')
					this.highlight(selection, this.turn, false, false)
					if(this.botBool && this.turn == -1)	
						this.bot()
				}
				//SI LA CASE SELECTIONNE EST HIGHLIGHT : SE DEPLACER, CHANGER LE TOUR ET ANALYSER SI ECHEC
				if(Array.from(selection.classList).includes('highlight'))
				{
					this.deplace(this.selection, selection)
					//FIN PROVISOIRE LORSQUE LE ROI EST MORT
					if(this.body.querySelectorAll('#king').length < 2)
					{
						this.clean()
						alert('Les ' + (this.turn == 1 ? 'blancs' : 'noirs') + ' ont gagnÃ©s.')
						return
					}
					this.turn = (this.turn == 1) ? -1 : 1
					this.check()
					this.clean()
					this.limitedPiece = undefined
					if(this.rowColInCheck == null)
						this.checkPat()
					this.whoIsLimited()
					if(this.botBool && this.turn == -1)
						this.bot()
				}
				//SI LA CASE EST VIDE ENLEVE LA SELECTION ACTUELLE
				if(!selection.id)
					this.clean()
			},
			
			paving : function(td, i, j)
			{//MISE EN PLACE DE LA COULEUR DES CASES
				if((i+1) % 2 == 0)
				{
					if((j+1) % 2 == 0)
						td.classList.add('white')
					else
						td.classList.add('black')
				}
				else
				{
					if((j+1) % 2 != 0)
						td.classList.add('white')
					else
						td.classList.add('black')		
				}
			},
			
			initialPos : function(td, i, j)
			{//POSITIONNEMENT INITIAL DES PIECES
				if(i == 1)
				{
					td.id = this.pieces[0]
					td.dataset.player = 1
				}		
				if(i == this.row - 2)
				{
					td.id = this.pieces[0]
					td.dataset.player = -1
				}
				if(i == 0)
				{
					td.id = this.pieces[j+1]
					td.dataset.player = 1
				}
				if(i == this.row - 1)
				{
					td.id = this.pieces[j+1]
					td.dataset.player = -1
				}
			},
			
			clean : function()
			{
				this.selection.classList.remove('select')
				for(let i = 0; i < this.row; i++)
					for(let j = 0; j < this.col; j++)
						this.tabJS[i][j].classList.remove('highlight')
			},
			
			deplace : function(oldPos, newPos)
			{
				this.body.querySelector('audio').play()
				newPos.setAttribute('data-player', oldPos.getAttribute('data-player'))
				oldPos.removeAttribute('data-player')
				newPos.id = oldPos.id
				oldPos.removeAttribute('id')
			},
			
			check : function()
			{
				const currentPlayerPieces = Array.from(this.body.querySelectorAll(`[data-player='${this.turn}']`))
				const opposantPlayerPieces = Array.from(this.body.querySelectorAll(`[data-player='${-this.turn}']`))
				const currentPlayerKing = this.body.querySelector(`#king[data-player='${this.turn}']`)
				const opposantPlayerKing = this.body.querySelector(`#king[data-player='${-this.turn}']`)
				
				opposantPlayerPieces.map(x => x.classList.remove('freeze'))
				
				if(this.rowColInCheck != undefined)
				{
					this.tabJS[this.rowColInCheck[0]][this.rowColInCheck[1]].classList.remove('check')
					this.rowColInCheck = undefined
					this.threatToKing = null
				}
				else
				{
					for(let i = 0; i < opposantPlayerPieces.length; i++)
					{
						this.highlight(opposantPlayerPieces[i], -this.turn)
						if(Array.from(currentPlayerKing.classList).includes('highlight'))
						{
							currentPlayerKing.classList.add('check')
							this.rowColInCheck = [currentPlayerKing.dataset.row, currentPlayerKing.dataset.column]
							this.clean()
							this.threatToKing = this.calcThreatToKing(currentPlayerPieces, opposantPlayerPieces[i], currentPlayerKing)
							this.saveTheKing(currentPlayerPieces, opposantPlayerPieces[i], currentPlayerKing)
							this.checkMate(currentPlayerPieces)
						}
					}
				}
			},
			
			checkMate : function(currentPlayerPieces)
			{
				for(let i = 0; i < currentPlayerPieces.length; i++)
					if(!Array.from(currentPlayerPieces[i].classList).includes('freeze'))
						return
				this.panel('CHECKMATE !', true)
                this.botBool = false
			},
			
			checkPat : function()
			{
				let count = 0
				const currentPlayerPieces = Array.from(this.body.querySelectorAll(`[data-player='${this.turn}']`))
				console.log(currentPlayerPieces)
				for(let i = 0; i < currentPlayerPieces.length; i++)
				{
					 this.highlight(currentPlayerPieces[i])
					 count += this.body.querySelectorAll('.highlight').length
				}
				if(count == 0)
				{
					this.panel('PAT !', true)
                    this.botBool = false
				}
				this.clean()			
			},
            
            panel : function(text, restart)
            {
                const panel = document.createElement('div')
                panel.textContent = text
                if(restart)
                {
                    const btn = document.createElement('button')
                    btn.textContent = 'Restart'
                    btn.addEventListener('click', clickOnBtn)
                    panel.appendChild(btn)
                }
                this.body.querySelector('table').appendChild(panel) 
            },
			
			calcThreatToKing : function(currentPlayerPieces, threat, king)
			{
				const kingRow = king.dataset.row
				const kingCol = king.dataset.column
				const threatRow = parseInt(threat.dataset.row)
				const threatCol = parseInt(threat.dataset.column)
				const threatToKing = [[threatRow, threatCol]]
				let tempRow = threatRow
				let tempCol = threatCol
				let signRow
				let signCol
				
				if(threatRow > kingRow)
					signRow = -1
				else if (threatRow < kingRow)
					signRow = 1
				else
					signRow = 0

				if(threatCol > kingCol)
					signCol = -1
				else if (threatCol < kingCol)
					signCol = 1
				else
					signCol = 0
					
				if(threat.id == 'knight')
					threatToKing.push([threatRow, threatCol])
				else
				{
					const limitRow = parseInt(kingRow) + parseInt(-signRow)
					const limitCol = parseInt(kingCol) + parseInt(-signCol)
					tempRow = parseInt(tempRow)
					tempCol = parseInt(tempCol)
					//STOCKAGE DES CASES ENTRE LA MENACE(COMPRIS) ET LE ROI(NON COMPRIS) DANS L'ARRAY threatToKing
					while(tempRow != limitRow || tempCol != limitCol)
					{	
						if(tempRow != limitRow)
							tempRow = parseInt(Number(signRow) + Number(tempRow))
						if(tempCol != limitCol)
							tempCol = parseInt(Number(signCol) + Number(tempCol))
						threatToKing.push([tempRow, tempCol])
					}
				}
					return threatToKing					
			},
			
			saveTheKing : function(currentPlayerPieces, threat, king)
			{
				for(let j = 0; j < currentPlayerPieces.length; j++)
				{
					this.highlight(currentPlayerPieces[j], this.turn, false)
					if(currentPlayerPieces[j].id != 'king')
					{
						for(let k = 0; k < this.threatToKing.length; k++)
						{
							if(Array.from(this.tabJS[this.threatToKing[k][0]][this.threatToKing[k][1]].classList).includes('highlight'))
							{
								currentPlayerPieces[j].classList.remove('freeze')
								break
							}
							else
								currentPlayerPieces[j].classList.add('freeze')
						}
					this.clean()
					}
					else
					{
						currentPlayerPieces[j].classList.add('freeze')
						for(let a = 0; a < this.row; a++)
							for(let b = 0; b < this.col; b++)
								if(Array.from(this.tabJS[a][b].classList).includes('highlight'))
								{
									currentPlayerPieces[j].classList.remove('freeze')
									a = this.row
									b = this.col
								}
						this.clean()
					}
				}	
			},
			
			whoIsLimited : function()
			{
				const opposantPlayerPieces = Array.from(this.body.querySelectorAll(`[data-player='${-this.turn}']`))
				const currentPlayerPieces = Array.from(this.body.querySelectorAll(`[data-player='${this.turn}']`))
				const currentPlayerKing = this.body.querySelector(`#king[data-player='${this.turn}']`)
				for(let i = 0; i < opposantPlayerPieces.length; i++)
				{
					this.highlight(opposantPlayerPieces[i], -this.turn, false, true, true)
					if(Array.from(currentPlayerKing.classList).includes('highlight') && opposantPlayerPieces[i].id != 'king')
					{
						currentPlayerKing.classList.remove('highlight')
						this.threatToKingCommon = this.calcThreatToKing(currentPlayerPieces, opposantPlayerPieces[i], currentPlayerKing)
						let count = 0
						let tempLimitedPiece
						for(rowAndCol of this.threatToKingCommon)								
							if(Array.from(this.tabJS[rowAndCol[0]][rowAndCol[1]].classList).includes('highlight') && this.tabJS[rowAndCol[0]][rowAndCol[1]].dataset.player == this.turn)
							{
								tempLimitedPiece = this.tabJS[rowAndCol[0]][rowAndCol[1]]
								count++
							}
						if(count == 1)
							this.limitedPiece = tempLimitedPiece
						else
						{
							this.clean()
							break
						}
					}
					this.clean()
				}
			},
			
			highlight : function(selected, turnArg = this.turn, inception = false, analyse = true, inception_2 = false)
			{
				const selectedRow = Number(selected.getAttribute('data-row'))
				const selectedCol = Number(selected.getAttribute('data-column'))
				const selectedPlayer = selected.getAttribute('data-player')
				const opposantPlayerPieces = Array.from(this.body.querySelectorAll(`[data-player='${-this.turn}']`))
				const turn = turnArg
				//SI LA PIECE SELECTIONNEE N'EST PAS FREEZE
				if(!Array.from(selected.classList).includes('freeze'))
				{
					switch(selected.id)
					{
						case 'pawn':
						{
							if(!inception_2 && (selectedRow < this.row-1 && selectedRow > 0))
							{
								//HIGHLIGHT DE LA CASE DEVANT LE PION (SI LA CASE EXISTE ET SI ELLE EST VIDE) ET QUE LA FONCTION N'EST PAS APPELEE PAR LE ROI
								if(((selectedRow+turn >= 0 || selectedRow+turn <= this.row) && !this.tabJS[selectedRow+turn][selectedCol].id) && !inception)
									this.tabJS[selectedRow+turn][selectedCol].classList.add('highlight')
							//HIGHLIGHT DE LA DEUXIEME CASE DEVANT LE PION (S'IL EST A L'EMPLACEMENT INITIAL ET QU'AUCUNE PIECE BLOQUE LE CHEMIN) ET QUE LA FONCTION N'EST PAS APPELEE PAR LE ROI
								if(((turn == 1 && selectedRow == 1 || turn == -1 && selectedRow == this.row - 2) && !this.tabJS[selectedRow+turn][selectedCol].id && !this.tabJS[selectedRow+(turn*2)][selectedCol].id) && !inception)
									this.tabJS[selectedRow+(turn*2)][selectedCol].classList.add('highlight')
							//HIGHLIGHT DE LA CASE EN DIAGONAL SI ELLE EXISTE ET (EST PRISE PAR UNE PIECE ADVERSE OU QUE LA FONCTION EST APPELEE PAR LE ROI)
								if((selectedRow+turn >= 0 || selectedRow+turn <= this.row) && (selectedCol+1 < this.col))
									if(inception || this.tabJS[selectedRow+turn][selectedCol+1].dataset.player == -turn)
										this.tabJS[selectedRow+turn][selectedCol+1].classList.add('highlight')
							//HIGHLIGHT DE LA CASE EN ANTIDIAGONAL SI ELLE EXISTE ET (EST PRISE PAR UNE PIECE ADVERSE OU QUE LA FONCTION EST APPELEE PAR LE ROI)
								if((selectedRow+turn >= 0 || selectedRow+turn <= this.row) && (selectedCol-1 >= 0))
									if(inception || this.tabJS[selectedRow+turn][selectedCol-1].dataset.player == -turn)
										this.tabJS[selectedRow+turn][selectedCol-1].classList.add('highlight')
							//SI APPELEE PAR LA METHODE saveToKing SUPPRIME LES HIGHLIGHTS QUI NE SONT PAS COMPRIS ENTRE LE ROI ET LA MENACE
							}
							break;
						}
						case 'king':
						{
							if(!inception_2)
							{
							//TABLEAU CONTENANT LES DEPLACEMENTS D'UNE CASE DANS TOUTES LES DIRECTIONS
								const checkHighlight = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]]
								let toHighlight = []
								let checkRow
								let checkCol
								for(let j = 0; j < opposantPlayerPieces.length; j++)
								{
									//AJOUT DU HIGHLIGHT DE TOUS LES ENNEMIS (PAS LE ROI SI LA FONCTION EST APPELEE PAR LE ROI ADVERSE ET QU'ON EST SUR LE ROI)
									if(opposantPlayerPieces[j].id != 'king' || (opposantPlayerPieces[j].id == 'king' && !inception))
										this.highlight(opposantPlayerPieces[j], -this.turn, true)
									if((opposantPlayerPieces[j].id == 'queen' || opposantPlayerPieces[j].id == 'rook' || opposantPlayerPieces[j].id == 'bishop'))
										this.highlight(opposantPlayerPieces[j], -this.turn, false, true, true)
								}
								for(let i = 0; i < checkHighlight.length; i++)
								{
									checkRow = selectedRow+checkHighlight[i][0]
									checkCol = selectedCol+checkHighlight[i][1]
									//STOCKAGE DES CASES QUI NE DEBORDENT PAS DU PLATEAU, NE SONT PAS ALLIE ET NE SONT PAS DANS LE CHAMPS D'ATTAQUE D'UN ENNEMI
									if((checkRow <= this.row-1 && checkRow >= 0 && checkCol <= this.col-1 && checkCol >= 0) && this.tabJS[checkRow][checkCol].dataset.player != turn && !Array.from(this.tabJS[checkRow][checkCol].classList).includes('highlight'))
										toHighlight.push(this.tabJS[checkRow][checkCol])
										//CLEAN DU HIGHLIGHT DE TOUS LES HIGHLIGHTS SI LA FONCTION N'EST PAS APPELEE PAR LE ROI ADVERSE ET AJOUT DU CELUI DU ROI
								}
								if(!inception)
									this.clean()
								if(!analyse)
									chess.selection.classList.add('select')
								toHighlight.map(x => x.classList.add('highlight'))
								return
							}
							break
						}
						case 'knight':
						{
							if(!inception_2)
							{
							//TABLEAU CONTENANT LES DEPLACEMENTS POSSIBLE DU CAVALIER
								const checkHighlight = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]
								let checkRow
								let checkCol
								for(let i = 0; i < checkHighlight.length; i++)
								{
									checkRow = selectedRow+checkHighlight[i][0]
									checkCol = selectedCol+checkHighlight[i][1]
									//HIGHLIGHT DE LA CASE SI ELLE NE DEBORDE PAS DU PLATEAU ET (N'EST PAS ALLIE OU QUE LA FONCTION EST APPELEE PAR LE ROI)
									if((checkRow <= this.row-1 && checkRow >= 0 && checkCol <= this.col-1 && checkCol >= 0) && (this.tabJS[checkRow][checkCol].dataset.player != turn || inception))
										this.tabJS[checkRow][checkCol].classList.add('highlight')
								}
							}
							break;
						}
						case 'queen':
						case 'rook':
						case 'bishop':
						{
							let checkHighlight
							if(selected.id == 'queen')
							//TABLEAU CONTENANT LES DEPLACEMENTS D'UNE CASE DANS TOUTES LES DIRECTIONS
								checkHighlight = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]]
							else if(selected.id == 'rook')
							//TABLEAU CONTENANT LES DEPLACEMENTS D'UNE CASE EN HORIZONTAL ET VERTICAL
								checkHighlight = [[1,0],[-1,0],[0,1],[0,-1]]
							else if(selected.id == 'bishop')
							//TABLEAU CONTENANT LES DEPLACEMENTS D'UNE CASE EN DIAGONAL
								checkHighlight = [[1,1],[-1,1],[1,-1],[-1,-1]]
							let checkRow
							let checkCol
							//POUR CHAQUE DIRECTIONS DU TABLEAU
							for(let i = 0; i < checkHighlight.length; i++)
							//PROGRESSE CASE PAR CASE TANT QU'ELLE NE DEBORDE PAR DU PLATEAU. SI UNE PIECE SE TROUVE SUR LA CASE, ARRETE LA BOUCLE
								for(let j = 1; selectedRow+(checkHighlight[i][0]*j) <= this.row-1 && selectedRow+(checkHighlight[i][0]*j) >= 0 && selectedCol+(checkHighlight[i][1]*j) <= this.col-1 && selectedCol+(checkHighlight[i][1]*j) >= 0; j++)
									{
										checkRow = selectedRow+(checkHighlight[i][0]*j)
										checkCol = selectedCol+(checkHighlight[i][1]*j)
									//HIGHLIGHT DE LA CASE SI ELLE NE DEBORDE PAS DU PLATEAU ET (N'EST PAS ALLIE OU QUE LA FONCTION EST APPELEE PAR LE ROI)
										if((checkRow <= this.row-1 && checkRow >= 0 && checkCol <= this.col-1 && checkCol >= 0) && (this.tabJS[checkRow][checkCol].dataset.player != turn || inception))
											this.tabJS[checkRow][checkCol].classList.add('highlight')
									//ARRETE LA BOUCLE SI UNE PIECE EST SUR CETTE CASE 
										if((this.tabJS[checkRow][checkCol].id && !inception_2)  || (this.tabJS[checkRow][checkCol].dataset.player == turn))
											break
										else if(inception_2 && this.tabJS[checkRow][checkCol].id && this.tabJS[checkRow][checkCol].id != 'king' && (Array.from(this.body.querySelector(`#king[data-player='${this.turn}']`).classList).includes('select') || this.rowColInCheck != null))
											break
									}
						}
					}
					if(this.threatToKing && !analyse && selected.id != 'king')
					{
						const allHighlight = this.body.querySelectorAll('.highlight')
						for(let i = 0; i < allHighlight.length; i++)
						{
							allHighlight[i].classList.remove('highlight')
							let highlightRow = parseInt(allHighlight[i].dataset.row)
							let highlightCol = parseInt(allHighlight[i].dataset.column)
							for(let j = 0; j < this.threatToKing.length; j++)
								if(this.threatToKing[j][0] == highlightRow && this.threatToKing[j][1] == highlightCol)
									allHighlight[i].classList.add('highlight')
						}
					}
					
					if(!analyse && selected == this.limitedPiece)
					{
						for(let a = 0; a < this.row; a++)
							for(let b = 0; b < this.col; b++)
							{
								let count = 0
								for(let c = 0; c < this.threatToKingCommon.length; c++)
								{
									if((this.threatToKingCommon[c][0] == a && this.threatToKingCommon[c][1] == b) && (this.tabJS[this.limitedPiece.dataset.row][this.limitedPiece.dataset.column] != this.tabJS[this.threatToKingCommon[c][0]][this.threatToKingCommon[c][1]]) && Array.from(this.tabJS[a][b].classList).includes('highlight'))
										break
									else
										count++
									if(count == this.threatToKingCommon.length)
										this.tabJS[a][b].classList.remove('highlight')
								}	
							}
					}
				}
				return false
			},
			
			bot : function(selection)
			{
				let random
				let highlightCheck = false
				let botSelection
				for(let a = 0; a < this.row; a++)
					for(let b = 0; b < this.col; b++)
						if(Array.from(this.tabJS[a][b].classList).includes('highlight'))
						{
							highlightCheck = true
							a = this.row
							b = this.row
						}
				if(highlightCheck)
				{
					const highlighted = Array.from(this.body.querySelectorAll('.highlight'))
					random = Math.floor(Math.random() * highlighted.length)
					botSelection = highlighted[random]
					setTimeout(function(){chess.play(botSelection)}, 600)
				}
				else		
				{
					const currentPlayerPieces = Array.from(this.body.querySelectorAll(`[data-player='${this.turn}']`))
					do
					{
						random = Math.floor(Math.random() * currentPlayerPieces.length)
						botSelection = currentPlayerPieces[random]
					}
					while(this.selection == botSelection)
					this.play(botSelection)
				}	
			}
		}
		
		const row = 8
		const col = 8
		const bot = true
		chess.init(row, col, bot)
	</script>
</body>
</html>