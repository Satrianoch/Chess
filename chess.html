<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Chess</title>
	<style>
		body{margin:0;padding:0;background:#000}
		table{margin: auto;margin-top: 50vh;transform: translateY(-50%)}
		td{width:65px;height:65px;border:2px solid}
		.black{background:#433}
		.white{background:#FB1}
		.select{background:#23D}
		.highlight{background:#1CE}
		.check{background:#BA2B1E}
		.freeze{background:#B00B1E;opacity: 0.33}
		#pawn[data-player='-1']{background-image: url('img/pawnB.png'); background-size: 100% 100%}
		#pawn[data-player='1']{background-image: url('img/pawnW.png'); background-size: 100% 100%}
		#rook[data-player='-1']{background-image: url('img/rookB.png'); background-size: 100% 100%}
		#rook[data-player='1']{background-image: url('img/rookW.png'); background-size: 100% 100%}
		#bishop[data-player='-1']{background-image: url('img/bishopB.png'); background-size: 100% 100%}
		#bishop[data-player='1']{background-image: url('img/bishopW.png'); background-size: 100% 100%}
		#knight[data-player='-1']{background-image: url('img/knightB.png'); background-size: 100% 100%}
		#knight[data-player='1']{background-image: url('img/knightW.png'); background-size: 100% 100%}
		#queen[data-player='-1']{background-image: url('img/queenB.png'); background-size: 100% 100%}
		#queen[data-player='1']{background-image: url('img/queenW.png'); background-size: 100% 100%}
		#king[data-player='-1']{background-image: url('img/kingB.png'); background-size: 100% 100%}
		#king[data-player='1']{background-image: url('img/kingW.png'); background-size: 100% 100%}
	</style>
</head>
<body>
	<script>
		function clickOnTd()
		{
			if(chess.selection == undefined)
				chess.selection = this

			if(this.id && this.dataset.player == chess.turn)
			{
				chess.clean()
				chess.selection = this
				chess.highlight(this)
				this.classList.add('select')
			}
				
			if(Array.from(this.classList).includes('highlight'))
			{
				chess.deplace(chess.selection, this)
				//FIN PROVISOIRE LORSQUE LE ROI EST MORT
				if(chess.body.querySelectorAll('#king').length < 2)
				{
					chess.clean()
					alert('Les ' + (chess.turn == 1 ? 'blancs' : 'noirs') + ' ont gagnÃ©s.')
					return
				}
				chess.turn = (chess.turn == 1) ? -1 : 1
				chess.check()
				chess.clean()
			}
			//SI LA CASE EST VIDE ENLEVE LA SELECTION ACTUELLE
			if(!this.id)
				chess.clean()
		}
		
		const chess = 
		{ 
			init : function(row, col)
			{	
				this.row = row
				this.col = col
				this.body = document.body
				this.tabHTML = document.createElement('table')
				this.tabJS = []
				this.selection
				this.turn = 1
				this.pieces = ['pawn','rook','knight','bishop','king','queen','bishop','knight','rook']
				this.rowColInCheck
				
				for(let i = this.row-1; i >= 0; i--)
				{
					const tr = document.createElement('tr')
					this.tabJS[i] = []
					for(let j = 0; j < this.col; j++)
					{
						const td = document.createElement('td')
						td.dataset.row = i
						td.dataset.column = j
						
						this.paving(td, i, j)
						this.initialPos(td, i, j)
						td.addEventListener('click', clickOnTd)
						
						this.tabJS[i][j] = td
						tr.appendChild(td)
					}
					this.tabHTML.appendChild(tr)
				}
				this.body.appendChild(this.tabHTML)
			},
			
			paving : function(td, i, j)
			{//MISE EN PLACE DE LA COULEUR DES CASES
				if((i+1) % 2 == 0)
				{
					if((j+1) % 2 == 0)
						td.classList.add('white')
					else
						td.classList.add('black')
				}
				else
				{
					if((j+1) % 2 != 0)
						td.classList.add('white')
					else
						td.classList.add('black')		
				}
			},
			
			initialPos : function(td, i, j)
			{//POSITIONNEMENT INITIAL DES PIECES
				if(i == 1)
				{
					td.id = this.pieces[0]
					td.dataset.player = 1
				}		
				if(i == this.row - 2)
				{
					td.id = this.pieces[0]
					td.dataset.player = -1
				}
				if(i == 0)
				{
					td.id = this.pieces[j+1]
					td.dataset.player = 1
				}
				if(i == this.row - 1)
				{
					td.id = this.pieces[j+1]
					td.dataset.player = -1
				}
			},
			
			clean : function()
			{
				this.selection.classList.remove('select')
				for(let i = 0; i < this.row; i++)
					for(let j = 0; j < this.col; j++)
						this.tabJS[i][j].classList.remove('highlight')
			},
			
			deplace : function(oldPos, newPos)
			{
				newPos.setAttribute('data-player', oldPos.getAttribute('data-player'))
				oldPos.removeAttribute('data-player')
				newPos.id = oldPos.id
				oldPos.removeAttribute('id')
			},
			
			check : function()
			{
				const currentPlayerPieces = Array.from(this.body.querySelectorAll(`[data-player='${this.turn}']`))
				const opposantPlayerPieces = Array.from(this.body.querySelectorAll(`[data-player='${-this.turn}']`))
				const currentPlayerKing = this.body.querySelector(`#king[data-player='${this.turn}']`)
				const opposantPlayerKing = this.body.querySelector(`#king[data-player='${-this.turn}']`)
				
				opposantPlayerPieces.map(x => x.classList.remove('freeze'))
				
				if(this.rowColInCheck != undefined)
				{
					this.tabJS[this.rowColInCheck[0]][this.rowColInCheck[1]].classList.remove('check')
					this.rowColInCheck = undefined
				}
				else
				{
					for(let i = 0; i < opposantPlayerPieces.length; i++)
					{
						this.highlight(opposantPlayerPieces[i], -this.turn)
						if(Array.from(currentPlayerKing.classList).includes('highlight'))
						{
							currentPlayerKing.classList.add('check')
							this.rowColInCheck = [currentPlayerKing.dataset.row, currentPlayerKing.dataset.column]
							this.clean()
							this.saveTheKing(currentPlayerPieces, opposantPlayerPieces[i], currentPlayerKing)
						}
					}
				}
			},
			
			saveTheKing : function(currentPlayerPieces, threat, king)
			{
				const kingRow = king.dataset.row
				const kingCol = king.dataset.column
				const threatRow = threat.dataset.row
				const threatCol = threat.dataset.column
				let tempRow = threatRow
				let tempCol = threatCol
				let signRow
				let signCol
				let threatToKing = [[threatRow, threatCol]]
				
				if(threatRow > kingRow)
					signRow = -1
				else if (threatRow < kingRow)
					signRow = 1
				else
					signRow = 0

				if(threatCol > kingCol)
					signCol = -1
				else if (threatCol < kingCol)
					signCol = 1
				else
					signCol = 0
				
				
				const limitRow = parseInt(kingRow) + parseInt(-signRow)
				const limitCol = parseInt(kingCol) + parseInt(-signCol)
				tempRow = parseInt(tempRow)
				tempCol = parseInt(tempCol)
				//STOCKAGE DES CASES ENTRE LA MENACE(COMPRIS) ET LE ROI(NON COMPRIS) DANS L'ARRAY threatToKing
				while(tempRow != limitRow || tempCol != limitCol)
				{	
					if(tempRow != limitRow)
						tempRow = parseInt(Number(signRow) + Number(tempRow))
					if(tempCol != limitCol)
						tempCol = parseInt(Number(signCol) + Number(tempCol))
					threatToKing.push([tempRow, tempCol])
				}
				
				for(let j = 0; j < currentPlayerPieces.length; j++)
				{
					this.highlight(currentPlayerPieces[j])
					if(currentPlayerPieces[j].id != 'king')
					{
						for(let k = 0; k < threatToKing.length; k++)
						{
							if(Array.from(this.tabJS[threatToKing[k][0]][threatToKing[k][1]].classList).includes('highlight'))
							{
								currentPlayerPieces[j].classList.remove('freeze')
								break
							}
							else
								currentPlayerPieces[j].classList.add('freeze')
						}
					this.clean()
					}
					else
					{
						currentPlayerPieces[j].classList.add('freeze')
						for(let a = 0; a < this.row; a++)
							for(let b = 0; b < this.col; b++)
							{
								console.log(this.tabJS[a][b].dataset.row + threatToKing[threatToKing.length - 1][0] + this.tabJS[a][b].dataset.column + threatToKing[threatToKing.length - 1][1])
								if(Array.from(this.tabJS[a][b].classList).includes('highlight') && (this.tabJS[a][b].dataset.row != threatToKing[threatToKing.length - 1][0] || this.tabJS[a][b].dataset.column != threatToKing[threatToKing.length - 1][1]))
								{
									currentPlayerPieces[j].classList.remove('freeze')
									break
								}
							}
						this.clean()
					}
				}	
			},
					
			highlight : function(selected, turnArg = this.turn)
			{
				const selectedRow = Number(selected.getAttribute('data-row'))
				const selectedCol = Number(selected.getAttribute('data-column'))
				const selectedPlayer = selected.getAttribute('data-player')
				const turn = turnArg
				//SI LA PIECE SELECTIONNEE N'EST PAS FREEZE
				if(!Array.from(selected.classList).includes('freeze'))
					switch(selected.id)
					{
						case 'pawn':
						{
						//HIGHLIGHT DE LA CASE DEVANT LE PION SI LA CASE EXISTE ET SI ELLE EST VIDE
							if((selectedRow+turn >= 0 || selectedRow+turn <= this.row) && !this.tabJS[selectedRow+turn][selectedCol].id)
								this.tabJS[selectedRow+turn][selectedCol].classList.add('highlight')
						//HIGHLIGHT DE LA DEUXIEME CASE DEVANT LE PION S'IL EST A L'EMPLACEMENT INITIAL ET QU'AUCUNE PIECE BLOQUE LE CHEMIN
							if((turn == 1 && selectedRow == 1 || turn == -1 && selectedRow == this.row - 2) && !this.tabJS[selectedRow+turn][selectedCol].id && !this.tabJS[selectedRow+(turn*2)][selectedCol].id)
								this.tabJS[selectedRow+(turn*2)][selectedCol].classList.add('highlight')
						//HIGHLIGHT DE LA CASE EN DIAGONAL SI ELLE EXISTE ET EST PRISE PAR UNE PIECE ADVERSE
							if((selectedRow+turn >= 0 || selectedRow+turn <= this.row) && (selectedCol+1 < this.col) && this.tabJS[selectedRow+turn][selectedCol+1].dataset.player == -turn)
								this.tabJS[selectedRow+turn][selectedCol+1].classList.add('highlight')
						//HIGHLIGHT DE LA CASE EN ANTIDIAGONAL SI ELLE EXISTE ET EST PRISE PAR UNE PIECE ADVERSE
							if((selectedRow+turn >= 0 || selectedRow+turn <= this.row) && (selectedCol-1 >= 0) && this.tabJS[selectedRow+turn][selectedCol-1].dataset.player == -turn)
								this.tabJS[selectedRow+turn][selectedCol-1].classList.add('highlight')
							break;
						}
						case 'king':
						{
						//TABLEAU CONTENANT LES DEPLACEMENTS D'UNE CASE DANS TOUTES LES DIRECTIONS
							const checkHighlight = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]]
							let checkRow
							let checkCol
							for(let i = 0; i < checkHighlight.length; i++)
							{
								checkRow = selectedRow+checkHighlight[i][0]
								checkCol = selectedCol+checkHighlight[i][1]
								//HIGHLIGHT DE LA CASE SI ELLE NE DEBORDE PAS DU PLATEAU ET N'EST PAS ALLIE
								if((checkRow <= this.row-1 && checkRow >= 0 && checkCol <= this.col-1 && checkCol >= 0) && this.tabJS[checkRow][checkCol].dataset.player != turn)
									this.tabJS[checkRow][checkCol].classList.add('highlight')
							}
							break;
						}
						case 'knight':
						{
						//TABLEAU CONTENANT LES DEPLACEMENTS POSSIBLE DU CAVALIER
							const checkHighlight = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]
							let checkRow
							let checkCol
							for(let i = 0; i < checkHighlight.length; i++)
							{
								checkRow = selectedRow+checkHighlight[i][0]
								checkCol = selectedCol+checkHighlight[i][1]
								//HIGHLIGHT DE LA CASE SI ELLE NE DEBORDE PAS DU PLATEAU ET N'EST PAS ALLIE
								if((checkRow <= this.row-1 && checkRow >= 0 && checkCol <= this.col-1 && checkCol >= 0) && this.tabJS[checkRow][checkCol].dataset.player != turn)
									this.tabJS[checkRow][checkCol].classList.add('highlight')
							}
							break;
						}
						case 'queen':
						case 'rook':
						case 'bishop':
						{
							let checkHighlight
							if(selected.id == 'queen')
							//TABLEAU CONTENANT LES DEPLACEMENTS D'UNE CASE DANS TOUTES LES DIRECTIONS
								checkHighlight = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]]
							else if(selected.id == 'rook')
							//TABLEAU CONTENANT LES DEPLACEMENTS D'UNE CASE EN HORIZONTAL ET VERTICAL
								checkHighlight = [[1,0],[-1,0],[0,1],[0,-1]]
							else if(selected.id == 'bishop')
							//TABLEAU CONTENANT LES DEPLACEMENTS D'UNE CASE EN DIAGONAL
								checkHighlight = [[1,1],[-1,1],[1,-1],[-1,-1]]
							let checkRow
							let checkCol
							//POUR CHAQUE DIRECTIONS DU TABLEAU
							for(let i = 0; i < checkHighlight.length; i++)
							//PROGRESSE CASE PAR CASE TANT QU'ELLE NE DEBORDE PAR DU PLATEAU. SI UNE PIECE SE TROUVE SUR LA CASE, ARRETE LA BOUCLE
								for(let j = 1; selectedRow+(checkHighlight[i][0]*j) <= this.row-1 && selectedRow+(checkHighlight[i][0]*j) >= 0 && selectedCol+(checkHighlight[i][1]*j) <= this.col-1 && selectedCol+(checkHighlight[i][1]*j) >= 0; j++)
									{
										checkRow = selectedRow+(checkHighlight[i][0]*j)
										checkCol = selectedCol+(checkHighlight[i][1]*j)
									//HIGHLIGHT DE LA CASE SI ELLE NE DEBORDE PAS DU PLATEAU ET N'EST PAS ALLIE
										if((checkRow <= this.row-1 && checkRow >= 0 && checkCol <= this.col-1 && checkCol >= 0) && this.tabJS[checkRow][checkCol].dataset.player != turn)
											this.tabJS[checkRow][checkCol].classList.add('highlight')
									//ARRETE LA BOUCLE SI UNE PIECE EST SUR CETTE CASE 
										if(this.tabJS[checkRow][checkCol].id)
											break;
									}
						}
					}
			}
		}
		
		chess.init(8,8)
	</script>
</body>
</html>